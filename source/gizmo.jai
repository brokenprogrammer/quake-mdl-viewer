// This is random autogenerated code. Here is a todo list for what I want to do before moving on:
// 1. Better rendering, lines look like shit, add arrows / cones
// 2. Upgrade to work with multiple models, perhaps detect which one we are closest to or introduce a concept of "Selected" model.
// 3. Refactor so that it makes sense

g_gizmo_active: bool = false;
g_gizmo_axis: string = ""; // "x", "y", or "z"
g_gizmo_start_mouse_pos: Vector2_GLfloat;
g_gizmo_start_light_pos: Vector3_Float32;

handle_gizmo_interaction :: () {
    mouse_x, mouse_y := get_mouse_pointer_position();
    
    // Convert mouse position to OpenGL coordinates (if needed)
    // Some window systems may have different coordinate orientations
    viewport: [4]s32;
    glGetIntegerv(GL_VIEWPORT, *viewport[0]);
    mouse_pos := Vector2_GLfloat.{cast(float32) mouse_x, cast(float32) mouse_y};
    
    // If using debug, print mouse position
    if is_key_down(.MOUSE_BUTTON_LEFT) {
        print("Mouse position: %, %\n", mouse_pos.x, mouse_pos.y);
    }

    if is_key_down(.MOUSE_BUTTON_LEFT) {
        if !g_gizmo_active {
            // Check if mouse is near any of the gizmo axes
            axis, distance := check_gizmo_axis_hit(mouse_pos);
            if distance < GIZMO_AXIS_HIT_THRESHOLD {
                print("Gizmo axis hit: % with distance: %\n", axis, distance);
                g_gizmo_active = true;
                g_gizmo_axis = axis;
                g_gizmo_start_mouse_pos = mouse_pos;
                g_gizmo_start_light_pos = .{light_pos.x, light_pos.y, light_pos.z};
            }
        } else {
            // Drag the light position based on mouse movement
            delta_x := mouse_pos.x - g_gizmo_start_mouse_pos.x;
            delta_y := mouse_pos.y - g_gizmo_start_mouse_pos.y;

            sensitivity: float32 = 0.01; // Adjust as needed
            
            // Consider camera orientation for more intuitive movement
            // Here we use simple axis mapping, but you could use camera-relative movement
            if g_gizmo_axis == "x" {
                light_pos.x = g_gizmo_start_light_pos.x + delta_x * sensitivity;
            } else if g_gizmo_axis == "y" {
                // Note: often we invert Y movement since screen Y is down but world Y is up
                light_pos.y = g_gizmo_start_light_pos.y - delta_y * sensitivity;
            } else if g_gizmo_axis == "z" {
                light_pos.z = g_gizmo_start_light_pos.z + delta_x * sensitivity;
            }
        }
    } else {
        g_gizmo_active = false;
        g_gizmo_axis = "";
    }
}

check_gizmo_axis_hit :: (mouse_pos: Vector2_GLfloat) -> string, float {
    // Get viewport dimensions
    viewport: [4]s32;
    glGetIntegerv(GL_VIEWPORT, *viewport[0]);
    viewport_width := cast(float32) viewport[2];
    viewport_height := cast(float32) viewport[3];
    
    // Adjust mouse Y coordinate if necessary (if your mouse coordinates are top-down)
    // mouse_pos.y = viewport_height - mouse_pos.y;
    
    // Project light position to screen space
    light_pos_world := Vector3.{light_pos.x, light_pos.y, light_pos.z};

    // Define axis endpoints in world space (adjust length as needed)
    axis_length: float32 = 0.5;  // Increased length for easier selection
    x_axis_end_world: Vector3 = light_pos_world + .{axis_length, 0.0, 0.0};
    y_axis_end_world: Vector3 = light_pos_world + .{0.0, axis_length, 0.0};
    z_axis_end_world: Vector3 = light_pos_world + .{0.0, 0.0, axis_length};

    // Project world positions to clip space
    light_pos_clip := g_camera.view_projection_matrix * Vector4.{light_pos_world.x, light_pos_world.y, light_pos_world.z, 1.0};
    x_axis_end_clip := g_camera.view_projection_matrix * Vector4.{x_axis_end_world.x, x_axis_end_world.y, x_axis_end_world.z, 1.0};
    y_axis_end_clip := g_camera.view_projection_matrix * Vector4.{y_axis_end_world.x, y_axis_end_world.y, y_axis_end_world.z, 1.0};
    z_axis_end_clip := g_camera.view_projection_matrix * Vector4.{z_axis_end_world.x, z_axis_end_world.y, z_axis_end_world.z, 1.0};

    // Perspective divide - with safety checks
    if light_pos_clip.w <= 0.0 return "", 9999.0;  // Skip if behind camera
    if x_axis_end_clip.w <= 0.0 return "", 9999.0;
    if y_axis_end_clip.w <= 0.0 return "", 9999.0;
    if z_axis_end_clip.w <= 0.0 return "", 9999.0;
    
    light_pos_clip.x /= light_pos_clip.w;
    light_pos_clip.y /= light_pos_clip.w;
    x_axis_end_clip.x /= x_axis_end_clip.w;
    x_axis_end_clip.y /= x_axis_end_clip.w;
    y_axis_end_clip.x /= y_axis_end_clip.w;
    y_axis_end_clip.y /= y_axis_end_clip.w;
    z_axis_end_clip.x /= z_axis_end_clip.w;
    z_axis_end_clip.y /= z_axis_end_clip.w;

    // To screen coordinates
    light_pos_screen: Vector2_GLfloat;
    light_pos_screen.x = (light_pos_clip.x * 0.5 + 0.5) * viewport_width;
    light_pos_screen.y = (1.0 - (light_pos_clip.y * 0.5 + 0.5)) * viewport_height; // Adjust for OpenGL Y-up to screen Y-down
    
    x_axis_end_screen: Vector2_GLfloat;
    x_axis_end_screen.x = (x_axis_end_clip.x * 0.5 + 0.5) * viewport_width;
    x_axis_end_screen.y = (1.0 - (x_axis_end_clip.y * 0.5 + 0.5)) * viewport_height;
    
    y_axis_end_screen: Vector2_GLfloat;
    y_axis_end_screen.x = (y_axis_end_clip.x * 0.5 + 0.5) * viewport_width;
    y_axis_end_screen.y = (1.0 - (y_axis_end_clip.y * 0.5 + 0.5)) * viewport_height;
    
    z_axis_end_screen: Vector2_GLfloat;
    z_axis_end_screen.x = (z_axis_end_clip.x * 0.5 + 0.5) * viewport_width;
    z_axis_end_screen.y = (1.0 - (z_axis_end_clip.y * 0.5 + 0.5)) * viewport_height;

    // Debug output for troubleshooting
    print("Light pos screen: (%, %)\n", light_pos_screen.x, light_pos_screen.y);
    print("Mouse pos: (%, %)\n", mouse_pos.x, mouse_pos.y);

    // Calculate distances from mouse to each axis
    distance_x := distance_point_to_line(mouse_pos, light_pos_screen, x_axis_end_screen);
    distance_y := distance_point_to_line(mouse_pos, light_pos_screen, y_axis_end_screen);
    distance_z := distance_point_to_line(mouse_pos, light_pos_screen, z_axis_end_screen);
    
    print("Distances - X: %, Y: %, Z: %\n", distance_x, distance_y, distance_z);

    // Find the closest axis
    closest_axis: string = "";
    min_distance: float32 = 9999.0;

    if distance_x < min_distance {
        min_distance = distance_x;
        closest_axis = "x";
    }
    if distance_y < min_distance {
        min_distance = distance_y;
        closest_axis = "y";
    }
    if distance_z < min_distance {
        min_distance = distance_z;
        closest_axis = "z";
    }

    return closest_axis, min_distance;
}

distance_point_to_line :: (point: Vector2_GLfloat, line_start: Vector2_GLfloat, line_end: Vector2_GLfloat) -> float32 {
    // Calculate distance from a point to a line segment
    line_vector := line_end - line_start;
    point_vector := point - line_start;

    line_length_squared := line_vector.x * line_vector.x + line_vector.y * line_vector.y;
    if line_length_squared == 0.0 return length(point_vector); // Avoid division by zero

    t := max(0.0, min(1.0, dot(point_vector, line_vector) / line_length_squared));
    projection := line_start + (line_vector * t); // Fix: The calculation was incorrect

    return length(point - projection);
}

// // In your render function, call handle_gizmo_interaction
// render :: (mdl_model: Model, frame: int, frame_next: int, anim_lerp: float, aspect: float, rotate: bool, angle: float, anim_index: int, skin_index: int, shading_mode: s32, show_normals: bool, show_skybox: bool) {
//     // ...existing code...
//     handle_gizmo_interaction(g_input.mouse_pos);
//     // ...existing code...
// }

// Define a threshold for axis hit detection
GIZMO_AXIS_HIT_THRESHOLD :: 30.0; // Adjust as needed

// In your UI, add a Vector3 control for light position
// ui_vector3("Light Position", *g_params.light_pos);

// Draw the gizmo in screen space
draw_gizmo :: () {
    // Project light position to screen space (same as in check_gizmo_axis_hit)
    light_pos_world := Vector3.{light_pos.x, light_pos.y, light_pos.z};
    
    // Define axis endpoints in world space (adjust length as needed)
    axis_length: float32 = 0.5; // Use same axis_length as in check_gizmo_axis_hit
    x_axis_end: Vector3 = light_pos_world + .{axis_length, 0.0, 0.0};
    y_axis_end: Vector3 = light_pos_world + .{0.0, axis_length, 0.0};
    z_axis_end: Vector3 = light_pos_world + .{0.0, 0.0, axis_length};

    // Define axis colors
    x_axis_color: Vector4 = .{1.0, 0.0, 0.0, 1.0}; // Red
    y_axis_color: Vector4 = .{0.0, 1.0, 0.0, 1.0}; // Green
    z_axis_color: Vector4 = .{0.0, 0.0, 1.0, 1.0}; // Blue

    // Highlight axis if active
    if g_gizmo_active {
        if g_gizmo_axis == "x" {
            x_axis_color = .{1.0, 1.0, 0.0, 1.0}; // Yellow
        } else if g_gizmo_axis == "y" {
            y_axis_color = .{1.0, 1.0, 0.0, 1.0}; // Yellow
        } else if g_gizmo_axis == "z" {
            z_axis_color = .{1.0, 1.0, 0.0, 1.0}; // Yellow
        }
    }

    // Disable depth testing to ensure the gizmo is always drawn on top
    glDisable(GL_DEPTH_TEST);
    glLineWidth(3.0); // Make lines thicker for better visibility

    // Draw X axis
    draw_line(light_pos_world, x_axis_end, x_axis_color);

    // Draw Y axis
    draw_line(light_pos_world, y_axis_end, y_axis_color);

    // Draw Z axis
    draw_line(light_pos_world, z_axis_end, z_axis_color);

    // Re-enable depth testing
    glLineWidth(1.0); // Reset line width
    glEnable(GL_DEPTH_TEST);
}